const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bodyParser = require('body-parser');
const Memcoin = require('./src/scripts/memcoinModel');

// mongodb+srv://xanxxz:G3ia50ss4HAdClgM@crypto.lt91nus.mongodb.net/?retryWrites=true&w=majority&appName=Crypto

const app = express();
const PORT = 3000;

// Middleware
app.use(cors());
app.use(bodyParser.json());

// ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/kursachCrypto', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('âœ… MongoDB connected'))
.catch((err) => console.error('âŒ MongoDB connection error:', err));

// ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }
});

const User = mongoose.model('User', userSchema);

// ðŸ”“ Ð Ð•Ð“Ð˜Ð¡Ð¢Ð ÐÐ¦Ð˜Ð¯ (Ð±ÐµÐ· Ñ…ÑÑˆÐ°)
app.post('/api/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    console.log('ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸ÑŽ:', email, password);

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      console.log('ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚');
      return res.status(400).json({ message: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚' });
    }

    const user = new User({ email, password });
    await user.save();
    console.log('ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ñ‘Ð½');

    res.status(201).json({ message: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ñ‘Ð½' });
  } catch (err) {
    console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸:', err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸:' });
  }
});


// ðŸ”“ Ð’Ð¥ÐžÐ” (Ð±ÐµÐ· bcrypt)
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });

    if (user.password !== password) return res.status(401).json({ message: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ' });

    res.json({ message: 'Ð’Ñ…Ð¾Ð´ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ñ…Ð¾Ð´Ð°' });
  }
});

app.post('/api/coins', async (req, res) => {
  try {
    const { name, ticker, image, description, ownerEmail } = req.body;

    if (!name || !ticker || !ownerEmail) {
      return res.status(400).json({ message: 'Name, ticker and ownerEmail are required' });
    }

    const coin = new Memcoin({ name, ticker, image, description, ownerEmail });
    await coin.save();

    res.status(201).json({ message: 'ÐœÐµÐ¼ÐºÐ¾Ð¸Ð½ ÑÐ¾Ð·Ð´Ð°Ð½', coin });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð¼ÐµÐ¼ÐºÐ¾Ð¸Ð½Ð°' });
  }
});


app.get('/api/coins', async (req, res) => {
  try {
    const { ownerEmail } = req.query;
    const filter = ownerEmail ? { ownerEmail } : {};
    const coins = await Memcoin.find(filter);
    res.json(coins);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch memcoins' });
  }
});


// Ð£Ð”ÐÐ›Ð˜Ð¢Ð¬ Ð¼ÐµÐ¼ÐºÐ¾Ð¸Ð½ Ð¿Ð¾ ID
app.delete('/api/coins/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await Memcoin.findByIdAndDelete(id);
    res.json({ message: 'Memcoin deleted' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð¼ÐµÐ¼ÐºÐ¾Ð¸Ð½Ð°' });
  }
});

// Ð—Ð°Ð¿ÑƒÑÐº ÑÐµÑ€Ð²ÐµÑ€Ð°
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
});
